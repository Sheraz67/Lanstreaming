name: Build

on:
  push:
    branches: [main, master]
    tags: ['v*']
  pull_request:
    branches: [main, master]
  workflow_dispatch:

jobs:
  # ─────────────────────────────────────────────
  # Linux — build + test + AppImage
  # ─────────────────────────────────────────────
  linux:
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            cmake build-essential pkg-config \
            libavcodec-dev libavformat-dev libavutil-dev \
            libswscale-dev libswresample-dev \
            libx11-dev libxext-dev libpulse-dev \
            curl fuse libfuse2

      - name: Configure
        run: cmake -B build -DCMAKE_BUILD_TYPE=Release

      - name: Build
        run: cmake --build build -j$(nproc)

      - name: Test
        run: ctest --test-dir build --output-on-failure

      - name: Build AppImage
        run: bash packaging/build-appimage.sh

      - name: Upload AppImage
        uses: actions/upload-artifact@v4
        with:
          name: Lancast-Linux-x86_64-AppImage
          path: Lancast-*.AppImage

  # ─────────────────────────────────────────────
  # macOS — build + DMG
  # ─────────────────────────────────────────────
  macos:
    runs-on: macos-14  # Apple Silicon (M1) runner
    steps:
      - uses: actions/checkout@v4

      - name: Install FFmpeg via Homebrew
        run: brew install ffmpeg pkg-config

      - name: Configure
        run: cmake -B build -DCMAKE_BUILD_TYPE=Release

      - name: Build
        run: cmake --build build -j$(sysctl -n hw.ncpu)

      - name: Create .app bundle
        run: |
          APP="build/Lancast.app"
          VERSION="0.1.0"
          FRAMEWORKS_DIR="$APP/Contents/Frameworks"
          MACOS_DIR="$APP/Contents/MacOS"

          # Create bundle structure
          mkdir -p "$MACOS_DIR" "$APP/Contents/Resources" "$FRAMEWORKS_DIR"
          cp build/lancast "$MACOS_DIR/lancast"
          sed "s/VERSION_PLACEHOLDER/$VERSION/g" packaging/Info.plist > "$APP/Contents/Info.plist"

          # Create .icns icon
          ICONSET="build/lancast.iconset"
          mkdir -p "$ICONSET"
          sips -z 16 16     packaging/lancast.png --out "$ICONSET/icon_16x16.png"      > /dev/null 2>&1
          sips -z 32 32     packaging/lancast.png --out "$ICONSET/icon_16x16@2x.png"   > /dev/null 2>&1
          sips -z 32 32     packaging/lancast.png --out "$ICONSET/icon_32x32.png"      > /dev/null 2>&1
          sips -z 64 64     packaging/lancast.png --out "$ICONSET/icon_32x32@2x.png"   > /dev/null 2>&1
          sips -z 128 128   packaging/lancast.png --out "$ICONSET/icon_128x128.png"    > /dev/null 2>&1
          sips -z 256 256   packaging/lancast.png --out "$ICONSET/icon_128x128@2x.png" > /dev/null 2>&1
          sips -z 256 256   packaging/lancast.png --out "$ICONSET/icon_256x256.png"    > /dev/null 2>&1
          iconutil -c icns "$ICONSET" -o "$APP/Contents/Resources/lancast.icns"

      - name: Bundle dynamic libraries
        shell: bash
        run: |
          APP="build/Lancast.app"
          FRAMEWORKS_DIR="$APP/Contents/Frameworks"
          MACOS_DIR="$APP/Contents/MacOS"
          BINARY="$MACOS_DIR/lancast"
          BUNDLED_LIST="build/.bundled_libs"
          rm -f "$BUNDLED_LIST"
          touch "$BUNDLED_LIST"

          # Function: get non-system dylib paths from a binary
          get_deps() {
            otool -L "$1" 2>/dev/null | awk 'NR>1 {print $1}' | while read -r lib; do
              case "$lib" in
                /System/*|/usr/lib/*|@executable_path/*|@loader_path/*) continue ;;
                @rpath/*)
                  rpath_name="${lib#@rpath/}"
                  resolved=$(find build/_deps/sdl3-build -name "$rpath_name" 2>/dev/null | head -1)
                  if [ -n "$resolved" ] && [ -f "$resolved" ]; then echo "$resolved"; continue; fi
                  for prefix in /opt/homebrew/lib /usr/local/lib; do
                    if [ -f "$prefix/$rpath_name" ]; then echo "$prefix/$rpath_name"; break; fi
                  done
                  ;;
                *) echo "$lib" ;;
              esac
            done
          }

          bundle_lib() {
            local lib_path="$1"
            local lib_name
            lib_name=$(basename "$lib_path")

            # Skip if already bundled (use grep on a flat file — Bash 3 compatible)
            if grep -qx "$lib_name" "$BUNDLED_LIST" 2>/dev/null; then
              return
            fi
            if [ ! -f "$lib_path" ]; then
              return
            fi

            local real_path
            real_path=$(python3 -c "import os; print(os.path.realpath('$lib_path'))")
            cp "$real_path" "$FRAMEWORKS_DIR/$lib_name"
            chmod 644 "$FRAMEWORKS_DIR/$lib_name"
            install_name_tool -id "@executable_path/../Frameworks/$lib_name" "$FRAMEWORKS_DIR/$lib_name"
            echo "$lib_name" >> "$BUNDLED_LIST"
            echo "  Bundled: $lib_name"

            for dep in $(get_deps "$FRAMEWORKS_DIR/$lib_name"); do
              bundle_lib "$dep"
            done
          }

          echo "Bundling libraries..."
          for lib in $(get_deps "$BINARY"); do
            bundle_lib "$lib"
          done

          # Rewrite all references to @executable_path
          echo "Fixing references..."
          fix_refs() {
            local target="$1"
            otool -L "$target" 2>/dev/null | awk 'NR>1 {print $1}' | while read -r ref; do
              local ref_name
              ref_name=$(basename "$ref")
              if [ -f "$FRAMEWORKS_DIR/$ref_name" ]; then
                local new_ref="@executable_path/../Frameworks/$ref_name"
                if [ "$ref" != "$new_ref" ]; then
                  install_name_tool -change "$ref" "$new_ref" "$target" 2>/dev/null || true
                fi
              fi
            done
          }

          fix_refs "$BINARY"
          for f in "$FRAMEWORKS_DIR"/*.dylib; do
            [ -f "$f" ] && fix_refs "$f"
          done

          # Verify no Homebrew paths remain
          echo "Verifying..."
          BAD=$(otool -L "$BINARY" 2>/dev/null | grep -E '/(opt/homebrew|usr/local)/' || true)
          if [ -n "$BAD" ]; then
            echo "WARNING: external references remain:"
            echo "$BAD"
          else
            echo "  Bundle is self-contained"
          fi

      - name: Code sign
        run: |
          # Sign frameworks first, then the app
          for f in build/Lancast.app/Contents/Frameworks/*.dylib; do
            [ -f "$f" ] && codesign --force --sign - "$f"
          done
          codesign --force --deep --sign - build/Lancast.app

      - name: Create DMG
        run: |
          DMG_STAGING="build/dmg-staging"
          mkdir -p "$DMG_STAGING"
          cp -R build/Lancast.app "$DMG_STAGING/"
          ln -s /Applications "$DMG_STAGING/Applications"
          hdiutil create -volname "Lancast" \
            -srcfolder "$DMG_STAGING" \
            -ov -format UDZO \
            "Lancast-0.1.0-macOS.dmg"

      - name: Upload DMG
        uses: actions/upload-artifact@v4
        with:
          name: Lancast-macOS-DMG
          path: Lancast-*.dmg

  # ─────────────────────────────────────────────
  # Windows — build + test
  # ─────────────────────────────────────────────
  windows:
    runs-on: windows-latest
    env:
      VCPKG_DEFAULT_TRIPLET: x64-windows
    steps:
      - uses: actions/checkout@v4

      - name: Install FFmpeg via vcpkg
        run: vcpkg install ffmpeg[avcodec,avformat,swscale,swresample,x264,opus]:x64-windows

      - name: Configure
        run: cmake -B build -DCMAKE_TOOLCHAIN_FILE="$env:VCPKG_INSTALLATION_ROOT/scripts/buildsystems/vcpkg.cmake"

      - name: Build
        run: cmake --build build --config Release

      - name: Test
        run: |
          $env:PATH = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows\bin;$env:PATH"
          ctest --test-dir build -C Release --output-on-failure

      - name: Upload executable and DLLs
        uses: actions/upload-artifact@v4
        with:
          name: Lancast-Windows-x64
          path: build/Release/

  # ─────────────────────────────────────────────
  # Release — upload artifacts when a tag is pushed
  # ─────────────────────────────────────────────
  release:
    if: startsWith(github.ref, 'refs/tags/v')
    needs: [linux, macos, windows]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          draft: false
          generate_release_notes: true
          files: |
            artifacts/Lancast-Linux-x86_64-AppImage/*
            artifacts/Lancast-macOS-DMG/*
            artifacts/Lancast-Windows-x64/*
